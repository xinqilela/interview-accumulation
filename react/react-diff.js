/*
https://segmentfault.com/a/1190000010686582
HTTPS://INFOQ.CN/ARTICLE/REACT-DOM-DIFF
* */

/*
 react 的虚拟dom是怎么实现的?
1.先说说为什么要使用Virturl DOM，因为操作真实DOM的耗费的性能代价太高，所以react内部使用js实现了一套dom结构。
  在每次操作真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，找出有变化的dom节点，然后对VC NM,其进行更新操作。
2.为了实现虚拟DOM，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型：
  假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中；
  假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，
  一层一层往下，直到没有子节点。
* */

/*
Virtual Dom 算法的实现也就是以下三步：
  1. 通过 JS 来模拟创建 DOM 对象
  2. 判断两个对象的差异
       没有新的节点，那么什么都不用做
       新的节点的 tagName 和 `key` 和旧的不同，就替换
       新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树
  3. 渲染差异
       深度遍历树，将需要做变更操作的取出来
       局部更新 DOM
* */

/*
diff算法：

* */

/*
组件间的比较策略总结如下：
1.如果是同类型组件，则按照原策略继续比较virtual DOM树；
2.如果不是，则将该组件判断为dirty component，然后卸载整个组件(包括其子节点)进行替换；
3.对于同类型组件，virtual DOM可能并没有发生任何变化，这时我们可以通过shouldCompoenentUpdate钩子来告诉该组件是否进行diff，从而提高大量的性能。
* */

/*
总结：
1.通过diff策略，将算法从O(n^3)简化为O(n)
2.分层求异，对tree diff进行优化
3.分组件求异，相同类生成相似树形结构、不同类生成不同树形结构，对component diff进行优化
4.设置key，对element diff进行优化
5.尽量保持稳定的DOM结构、避免将最后一个节点移动到列表首部、避免节点数量过大或更新过于频繁
* */