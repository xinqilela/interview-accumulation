/*
https://segmentfault.com/a/1190000010686582
HTTPS://INFOQ.CN/ARTICLE/REACT-DOM-DIFF
* */

/*
 react 的虚拟dom是怎么实现的?
1.先说说为什么要使用Virturl DOM，因为操作真实DOM的耗费的性能代价太高，所以react内部使用js实现了一套dom结构。
  在每次操作真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，找出有变化的dom节点，然后对其进行更新操作。
2.为了实现虚拟DOM，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型：
  假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中；
  假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，
  一层一层往下，直到没有子节点。
* */

/*
Virtual Dom 算法的实现也就是以下三步：
  1. 通过 JS 来模拟创建 DOM 对象
  2. 判断两个对象的差异
       没有新的节点，那么什么都不用做
       新的节点的 tagName 和 `key` 和旧的不同，就替换
       新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树
  3. 渲染差异
       深度遍历树，将需要做变更操作的取出来
       局部更新 DOM
* */

/*
diff算法：
  1.特点:
    两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构
    对于同一层次的一组子节点，可以通过唯一的id进行区分
  2.比较：
    React只会对两棵树同一层次且是同一父节点下的所有子节点进行比较，若节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步比较，这样只需对树进行一次遍历便能完成整个DOM输的比较。
    (1)不同节点类型的比较：
       当在树中同一位置前后出现了不同类型的节点，直接删除前面的节点，然后创建并插入新节点，如果该删除的节点之下有子节点，那么这些子节点会被完全删除，它们不会用于后面的比较
    (2)相同节点类型的比较：
       React会对属性进行重设从而实现节点的转换，但是虚拟DOM的style属性稍有不同，其值为一个对象，因此若style从{color：'red'}变为{font-weight:'bold'}会移除color样式添加font-weight样式
    (3)列表节点的比较：
       列表节点的操作通常包括添加、删除和排序。如果每个节点都没有唯一的标识，React 无法识别每一个节点，那么更新过程会很低效，React 会逐个对节点进行更新，转换到目标节点，如果对列表节点
       提供唯一的 key 属性可以帮助 React 定位到正确的节点进行比较，从而大幅减少 DOM 操作次数，提高了性能。
* */

/*
组件间的比较策略总结如下：
1.如果是同类型组件，则按照原策略继续比较virtual DOM树；
2.如果不是，则将该组件判断为dirty component，然后卸载整个组件(包括其子节点)进行替换；
3.对于同类型组件，virtual DOM可能并没有发生任何变化，这时我们可以通过shouldCompoenentUpdate钩子来告诉该组件是否进行diff，从而提高大量的性能。
* */

/*
总结：
1.分层求异，对tree diff进行优化
2.分组件求异，相同类生成相似树形结构、不同类生成不同树形结构，对component diff进行优化
3.设置key，对element diff进行优化
4.尽量保持稳定的DOM结构、避免将最后一个节点移动到列表首部、避免节点数量过大或更新过于频繁
* */