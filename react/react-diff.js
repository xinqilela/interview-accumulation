/*
https://segmentfault.com/a/1190000010686582
* */

/*
 react 的虚拟dom是怎么实现的?
1.先说说为什么要使用Virturl DOM，因为操作真实DOM的耗费的性能代价太高，所以react内部使用js实现了一套dom结构。
  在每次操作真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，找出有变化的dom节点，然后对其进行更新操作。
2.为了实现虚拟DOM，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型：
  假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中；
  假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，
  一层一层往下，直到没有子节点。
* */

/*
Virtual Dom 算法的实现也就是以下三步：
  1. 通过 JS 来模拟创建 DOM 对象
  2. 判断两个对象的差异
       没有新的节点，那么什么都不用做
       新的节点的 tagName 和 `key` 和旧的不同，就替换
       新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树
  3. 渲染差异
       深度遍历树，将需要做变更操作的取出来
       局部更新 DOM
* */

/*
diff算法有如下三个策略：
1.DOM节点跨层级的移动操作发生频率很低；
2.拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构；
3.对于同一层级的一组子节点，通过唯一id进行区分，即key。
基于各自的前提策略，React也分别进行了算法优化，来保证整体界面构建的性能。
* */

/*
虚拟DOM树分层比较:
1.两棵树只会对同一层次的节点进行比较，忽略DOM节点跨层级的移动操作。React只会对同一个父节点下的所有子节点进行比较。
当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。
这样只需要对树进行一次遍历，便能完成整个DOM树的比较。复杂度原先的指数增长变为线型增长。
2.如果真的发生跨层级移动，如某个DOM及其子节点进行移动挂到另一个DOM下时，React并不知道子树仅仅是发生了移动，
而是会直接销毁，并重新创建这个子树，然后再挂在到目标DOM上。
在实现自己的组件时，保持稳定的DOM结构会有助于性能的提升。React官方也不建议做跨层级的操作。在实际使用中，
可以通过CSS隐藏或显示某些节点，而不是真的移除或添加DOM节点。
* */

/*
组件间的比较策略总结如下：
1.如果是同类型组件，则按照原策略继续比较virtual DOM树；
2.如果不是，则将该组件判断为dirty component，然后卸载整个组件(包括其子节点)进行替换；
3.对于同类型组件，virtual DOM可能并没有发生任何变化，这时我们可以通过shouldCompoenentUpdate钩子来告诉该组件是否进行diff，从而提高大量的性能。
* */

/*
总结：
1.通过diff策略，将算法从O(n^3)简化为O(n)
2.分层求异，对tree diff进行优化
3.分组件求异，相同类生成相似树形结构、不同类生成不同树形结构，对component diff进行优化
4.设置key，对element diff进行优化
5.尽量保持稳定的DOM结构、避免将最后一个节点移动到列表首部、避免节点数量过大或更新过于频繁
* */