/*
https://juejin.im/entry/58b7ad418ac24766f5609206
*/

/*
margin第一个参数设为auto并不能垂直居中
*/
.red {
    width: 30px;
    height: 30px;
    background: red;
    margin: 0px auto;
}

#content {
    position: relative;
    left: 50%;
    float: left;
}

.float-div {
    position: relative;
    float: left;
    right: 0%;
}

/*
css盒模型：
  IE盒模型：width属性包括padding和border的宽度
  w3c标准盒模型：width属性不包括padding和border的宽度
  box-sizing：用于更改计算元素的默认css盒模型。
    1.content-box:默认值
    2.border-box:
    3.padding-box:
*/

/*
重回和回流:
1.重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘
2.回流是布局或者几何属性需要改变就称为回流。
  回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流
3.减少：
    使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流
    把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来
    不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
    CSS 选择符从右往左匹配查找，避免 DOM 深度过深
*/

/*
图层：
    一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。
    如何生成：
      3d变换: translate3d,translateZ
      position: fixed
      video、iframe标签
*/

/*
Formatting context:
 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。
 最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。
 BFC: "块级格式化上下文"。
     https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context
     https://juejin.im/post/5909db2fda2f60005d2093db#heading-0
     它是一个独立的渲染区域，只有Block box参与， 它规定了内部的Block Box如何布局，并且与这个区域外部毫不相干。
     如何生成：满足一下之一即可
         根元素
         float的值不为none
         overflow的值不为visible
         display的值为inline-block、table-cell、table-caption、flow-root
         position的值为absolute或fixed
     布局规则:
       内部的box会在垂直方向上逐个放置
       box垂直方向的距离由margin决定，属于同一个BFC的两个相邻的box的margin会发生重叠
       每个元素的margin box 的左边，与包含快的左边相接触，即使存在浮动也是如此
       BFC区域不会与float box重叠
       BFC级是页面上的一个个里的容器，容器里面的子元素不会影响到外面的元素
       计算BFC的高度时，浮动元素也参与计算
     应用：
       防止margin重叠，外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间　　　
       浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。
       自适应多兰布局
*/

/*
flex布局：
http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html
http://www.ruanyifeng.com/blog/2015/07/flex-examples.html
容器属性：
  flex-direction: row|row-reverse|column|column-reverse
  flex-wrap: nowrap|wrap|wrap-reverse
  flex-flow: row nowrap (flex-direction和flex-wrap的缩写)
  justify-content: flex-start|flex-end|center|space-between|space-around
  align-item: flex-start|flex-end|center|baseline|stretch
  align-content: 定义了多根轴线的对其方式，如果只有一根轴线则该属性将不起作用。
                 flex-start|flex-end|center|space-between|space-around|stretch
项目属性：
  order: 定义项目的排列顺序，默认为0。数值越小，越靠前。
  flex-grow: 定义项目的放大比例，默认为0，即 即使有剩余空间，也不进行放大。
  flex-shrink: 定义项目的缩小比例，默认为1，即 若剩余空间不足，则进行缩小。
  align-self: 允许单个项目有与其他项目不同的对其方式。
              flex-start|flex-end|center|baseline|stretch
  flex-basis: 定义了在分配多余空间前，项目在主轴上所占据的空间，浏览器根据这个属性判断主轴是否有剩余空间。
  flex: 1 1 auto(flex-grow、flex-shrink、flex-basis的缩写)
*/

/*
position布局：
  static：指定元素的位置为文档流中的正常布局位置（top,right,bottom,left,z-index无效）
  relative：相对于元素在正常文档流中的位置进行偏移定位（会为元素在文档流中的原本位置留下空白）
  absolute：相对于最近的非static定位祖先元素进行偏移定位（不为元素预留空间）
  fixed：相对于屏幕视口的位置进行偏移定位（不为元素预留空间）
  sticky：可以被认为是相对定位和固定定位的混合，元素在跨越特定的阈值前为相对定位，之后为固定定位。
  注：
    若被绝对定位的元素其height（width）被设定为auto,可以同时指定top和bottom（left和right）来填充可用的垂直(水平)空间,
    若height(width)不为auto,可以同时指定top和bottom（left和right）来实现垂直居中（水平居中）。
*/

/*
grid布局：
  是CSS中最强大的布局系统。 这是一个二维系统，这意味着它可以同时处理列和行，不像 flexbox 那样主要是一维系统。
你可以通过将CSS规则应用于父元素和该元素的子元素，来使用网格布局。
https://segmentfault.com/a/1190000012889793
  1.“fr”单位允许您将轨道大小设置为网格容器自由空间的一部分。自由空间是在排除所有不可伸缩的 grid item 之后计算得到的。
  父元素：
    justify-items沿着行轴对齐网格内的内容（与之对应的是 align-items, 即沿着列轴对齐）。
    justify-content设置网格容器内的网格的对齐方式。 此属性沿着行轴对齐网格（与之对应的是 align-content, 沿着列轴对齐）。
    grid-auto-columns / grid-auto-rows指定自动生成的网格轨道（又名隐式网格轨道）的大小。
    grid-auto-flow如果你存在没有显示指明放置在网格上的 grid item，则自动放置算法会自动放置这些项目。
  子元素：
    justify-self沿着行轴对齐grid item 里的内容（与之对应的是 align-self, 即沿列轴对齐）
  而该属性则用于控制自动布局算法的工作方式。
*/
.grid-wrapper {
    width: 100%;
    height: 300px;
    display: grid;
    grid-template-columns: 100px 100px 100px 100px;
    grid-template-rows: auto;
    grid-template-areas:
            "header header header header"
            "main main . sidebar"
            "footer footer footer footer";
    justify-items: center;
    align-items:end;
    justify-content: end;
}
.item{
    width: 50px;
    height: 50px;
    background: pink;
}

.item-a {
    grid-area: header;
    background: red;
}
.item-b {
    grid-area: main;
    background: yellow;
}
.item-c {
    grid-area: sidebar;
    background: gray;
}
.item-d {
    grid-area: footer;
    background: green;
}